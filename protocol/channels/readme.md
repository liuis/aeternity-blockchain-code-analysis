# 状态通道

状态通道允许实体彼此通信，目的是共同计算某些函数f。 这个f可以像“每分钟发送0.1个硬币”一样简单，也可以代表分散交换。 在我们的案例中，这些功能由智能合约代表，就像任何合法合约一样，如果一方试图恶意行事，我们需要仲裁者。 这个仲裁者是区块链。



 - 不信任
 - 链下与链上
 - 与区块链相同的保证

在描述所涉及的协议之前，我们将介绍一些形成我们的状态通道设计的高级问题。

## 目录

- Terms

- Notation

- Goals

   - Privacy

   - Security

   - Speed

   - Cost

- Channel types

- Topology

- Incentives

- Artefacts

- Fees

- Protocol

   - Communication

   - Overview

   - Messages

       - Off-chain

       - On-chain

   - Contract execution in channels

- Light node requirements

- Examples

- Future work

- References





## 条款

我们尝试遵循闪电网络使用的命名惯例，无论它在哪里有意义，希望能够使其他人更容易采用，尽管我们试图强制执行命名方法，例如： `channel_close_solo`而不是`solo_close_channel`或`channel_solo_close`。

 -  ***节点***：连接到区块链的客户端，可以通过IP地址和端口
 -  ***peer***：通道中的参与者
 -  ***channel***：用于两个对等体交换状态更新的离线方法，每个节点可以具有多个信道，并且一对节点也可以在彼此之间具有多个信道，这些信道应该通过一个连接进行多路复用。


## 注释

区块链上的所有对象都有一个类型，并且是唯一可寻址的。 我们将通过类型（Id）表示这一点，例如， 帐户（A）是地址A的帐户。如果我们想要获得该帐户的余额，我们使用帐户（A）.balance。


## 目标

 - 支持所有智能合约的通用解决方案
     - 如果一个状态通道是通用的，甚至更好，s.t. 它可以实例化，然后用于许多不同的合约
 - 通道的可组合性，即应用程序适用于A< - > B情况也应该在A <-B-> C（A到C通过B）的情况下工作
 - 无需关闭/重新打开通道即可升级
 - 前一个应该使状态通道长期存活
     - 这与隐私不一致
 - 应将链上（on chain）操作保持在最低限度
 - 参与者状态也应保持在最低限度，即O（log n）或最好是常数乘数
 - 使用区块链作为仲裁者，在一定程度上减少信任
 - 任何参与方都可以关闭通道，但不应该这样做

通常，理想的状态通道设计应该是对链上处理交互的严格改进。 我们将用于衡量改进的维度如下：

 - 隐私
 - 安全
 - 速度
 - 成本


### 隐私

由于我们目前没有努力隐藏互动方或其互动的性质，因此链上互动几乎不提供隐私。

状态通道至少表明，双方建立了一个渠道以及他们对渠道承诺的硬币数量，这没有任何改善。 在任何一方都没有试图作弊的情况下，他们的互动的确切性质仍未得到解决，因为相互关闭一个频道不需要发布任何国家。

考虑到这一点，国家频道在隐私方面略有改善。


### 安全

状态渠道提供与正常的在线交易几乎相同的安全保障。

 -  ***活跃度***：两个peers可以独立地启动一个通道的关闭，然后该区块链使用通常的活跃假设来处理该操作。
 -  ***无信任***：由于操作需要由两个对等方签署，并且他们根据他们对状态的看法签署操作，因此双方仅签署他们同意的操作，并且不需要信任另一个对等方。

因此安全性与此相当。


### 速度

打开状态通道会导致正常的链上延迟，但是在建立通道之后，操作可以像两个对等方一样快地执行，这应该是对链上交互的重大改进。


### 成本

使用状态通道需要至少两个链上事务，用于打开和关闭它们。 一旦建立了渠道，除非同行想要提取或存入资金，否则不需要进一步的链上交易。 即使在一次性交易的情况下，如果已经拥有其他开放渠道，那么仍然可能值得打开渠道，因此可能通过转发消息来获得费用。


## 通道类型

最通用的通道类型是允许对等方实例化通道内的任意智能合约，并且不限制可以参与此类通道的对等方数量。

我们的构造将尝试满足前一个属性，允许在频道中执行任意数量的任意智能合约，但将后者限制为每个频道两个对等点。这种限制主要是为了保持通道结构简单。每个频道当然可能有两个以上的参与者，要求他们所有人都注销每次更新，但这会产生很大的开销，并且当对等方停止响应时，会导致频道卡住的可能性增加。有一些方法可以避免活跃性问题，但是在那时我们还不清楚我们是在运营状态渠道还是已经侧链处理过。

考虑到这一点，通道中的两个对等体很可能不具有相同的角色，而是最终用于大多数通道的客户端 - 服务器布置，其中客户端使用服务器提供的服务，这是高度的可用的，也可能是一些众所周知的实体，反映了当前网络的现状。一个流行的例子是交换，用户通过状态渠道连接到交换机。这个过程将是无法信任的，因为交易所不会失去资金，而这些资金尚未签署给他们。


## 拓扑

目前还不是很清楚，广泛使用的频道网络的拓扑结构会是什么样子，但似乎最有可能是中心辐射模型。 这种模式似乎比分散的模式更可能，因为大多数用户将无法提供可靠的服务，通过网络的更长路径将锁定更多的资金，并且表面上也会产生更高的转发费用。

在中心辐射模型中，我们将拥有许多大型集线器，这些集线器将通过网络参与大多数路由。 这些集线器将紧密连接，为大多数用户提供高可用性和短路径。 反过来，这将导致隐私的丧失并使网络更加脆弱，因为其中一个中心的消失将对其整体连通性产生重大影响。


## 奖励

操作频道至少需要两次链上操作，因此需要基本的费用，这一事实可能会被恶意对等方滥用。由于关闭频道需要付费，他们可以与某人打开频道，然后拒绝合作，锁定硬币并让对方支付再次关闭频道所需的费用。

一旦频道开通，所有发生的操作都需要由所有参与者签字。这为最后签署更新的任何人创建了一个免费选项。这个问题可以通过在链上实施进展的能力来解决，即从渠道获取状态并让矿工执行合约调用，而另一方则不愿意签字。

考虑到这一点，建议用户在想要避免上述问题时要谨慎对待他们打开频道。

另一方面，将渠道中的每一个失败归咎于恶意也是有害的，并且导致对系统失去信任，并且导致用户花费更多的费用。

## Artefacts

状态通道的结果应该是什么？ 最简单的答案是参与者的链上余额的变化，但也可能希望将状态通道用作穷人的MPC，并且在链上签订非空状态的合同，理想情况下， 需要一个紧凑的证据，即给定的智能合约实际上产生了参与者提供的状态。

## 费用

如果我们认为状态通道是长期存在的对象，那么在处理费用时就会出现问题，需要在连锁交易中支付费用。

鉴于所有各方都需要签署所有协议，恶意方可能会在某些情况下对同行发送黑名单。如果费用来自渠道余额，那么最终可能会出现渠道余额低于矿工收取交易所需费用的情况。这里的结果是，黑色邮寄的同行会比连锁交易的成本损失更少的硬币，这不应该是很多。如果费用来自发送交易的账户，那么该账户可能最终没有足够的硬币，因此可能最终没有足够的资金来关闭渠道。这可能会更糟，因为渠道可能会持有大量资金。

在这种情况下，似乎直接从渠道余额中扣除费用作为其结束的一部分似乎是最明智的方法。

为了避免这种情况，如果链上费用达到某一点，同行应该考虑停止任何互动，其中及时关闭频道所需的费用接近频道的余额。

## 协议

The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in RFC 2119.


### 沟通

信道参与者之间的通信是对等的，并且应该通过可靠且有序的协议发生，例如， TCP。同行应该期望运行他们自己的节点，以便能够捕获与他们所涉及的渠道相关的交易，尽管将来将该工作外包给第三方，同时仍然是无信任的，将来可能是可能的。

参与状态信道需要两个节点能够相互通信。在整个文档中，我们将假设这是通过TCP / IP实现的。发现远程节点的IP_ADDR：PORT对的过程未在本文档中介绍，并假设在带外发生，除非它们都已经是状态通道网络的一部分，其中节点可以宣告其身份（IP_ADDR，PORT） ， ID）。

消息将在链上和链外发送。

离线通信必须加密。为了满足这一要求，我们使用与同步相同的传输协议，它提供加密和身份验证，并基于噪声协议。

每对节点应该至多有一个开放连接。由于每个通道都具有唯一的ID，因此可以轻松地多路复用通道，因此重新使用连接不会造成任何问题。


### 概述

下图应概述脱链off-chain状态机。
任何渠道的起点都是“关闭”状态。

```
+---+ channel_open                                                         +---+
|   | -------------> +-------------+                 error                 |   |
|   |                | initialized | ------------------------------------> |   |
|   | <------------- +-------------+                                       |   |
|   |   [timeout]/          | channel_accept                               |   |
|   |   [disconnect]        v                                              |   |
|   |                +-------------+                 error                 |   |
|   | <------------- |  accepted   | ------------------------------------> |   |
| c |   [timeout]/   +-------------+                                       | e |
| l |   [disconnect]        | funding_created                              | r |
| o |                       v                                              | r |
| s |                +-------------+                 error                 | o |
| e | <------------- | half_signed | ------------------------------------> | r |
| d |   [timeout]/   +-------------+                                       |   |
|   |   [disconnect]        | funding_signed                               |   |
|   |                       v                                              |   |
|   |                +-------------+  [disconnect]                         |   |
|   | <------------- |   signed    | -------------+  error                 |   |
|   |   [timeout]    +-------------+ -------------|----------------------> |   |
|   |                       |    |  shutdown      |                        |   |
|   |        funding_locked |    +------------+   |                        |   |
|   |                       |                 |   |                        |   |
|   |                       |                 |   v                        |   |
|   |                       v        [disconnect] +--------------+  error  |   |
|   |                +-------------+ ---------|-> | disconnected | ------> |   |
|   | <------------- |    open     |          |   +--------------+         |   |
|   |   [timeout]    +-------------+ <--------|------------+               |   |
|   |                 ^ |      |       channel_reestablish                 |   |
|   |       update_*/ | |      |              |                            |   |
|   |       ping/pong +-+      | shutdown     v                            |   |
|   |                          |    +-------------+ [disconnect]           |   |
|   |                          +--> |   closing   | ------------+          |   |
|   |                               +-------------+             |          |   |
|   |                                |  ^                       |          |   |
|   |                                |  | channel_reestablish   |          |   |
|   | <------------------------------+  |                       v          |   |
|   |       closing_signed              |         +--------------+  error  |   |
|   |                                   +-------- | disconnected | ------> |   |
+---+                                             +--------------+         +---+
  ^                                                                          |
  |                                                                          |
  +--------------------------------------------------------------------------+
```

***注意***：方括号`[]`中的术语不是由定义的显式消息
协议，但是底层传输协议的一部分。


在链  on-chain

```
+---+           channel_create
|   | --------------------------------> +--------------+
|   |                                   |     open     |
|   | <-------------------------------- +--------------+
|   |         channel_close_mutual             |    ^ |   channel_withdraw/
|   |                                          |    | | channel_snapshot_solo/
|   |                       channel_close_solo |    | |   channel_deposit/
|   |                                          |    | | channel_force_progress
|   |                                          |    | |
| c |                                          |    | |
| l | channel_close_mutual                     |    +-+
| o | <------------------- +--------------+    |
| s |                      |    closing   |    |
| e | <------------------- +--------------+    |
| d |    channel_settle      |          ^      |
|   |                        |          |      |
|   |         channel_slash/ |   [lock_timeout]|
|   |  channel_force_progress|          |      |
|   |                        |          |      |
|   |                        v          |      |
|   | channel_close_mutual +--------------+    |
|   | <------------------- |    locked    | <--+
|   |                      +--------------+
+---+                       | ^
                            | |
                      channel_slash/
                  channel_force_progress
                            | |
                            +-+
```

***注意***：`[lock_timeout]`不是协议的显式消息，而是
计时器到期。

### 合约执行

离线合约生命周期紧密代表着链式合约。合约是通过共同签署的脱链交易创建的。完成此操作后，两个渠道参与者都可以调用新合约。每个合约都有自己的状态和余额，可以通过合约调用进行修改。每一轮都会清除合约回调。如果最后一轮包含一个调用，它将成为调用树的一部分，否则树将为空。不同的客户端实现可以保持旧调用，以便参与者能够检查其返回值，但这不是协议的一部分。参与者可以从渠道的状态树中删除离线合约，并在其中重新分配其余额。

状态通道的每个参与者保持表示内部通道状态的状态树。该树由账户，合约和合约调用组成。虽然此树是渠道内部的，但在争议解决期间，其中一部分是在链上发布的，以便将区块链用作仲裁者。尽管在大多数情况下合约都是内部合约，但并非在所有情况下都是如此。隐私可以进一步改善。

合约呼叫执行依赖于两个参与者同意状态更新。在任何时候，参与者都可能失踪或拒绝合作进行有效的离线合约通话。我们称之为争议，可以通过强制进行链接来解决。这要求强制方为合约的执行提供足够的信息。成功的力量进步的结果是一个新的渠道脱链状态。这样我们就可以无限制地保持合约渠道。

## 轻节点要求

## 未来的工作


## 参考文献

[1]: Lightning Network RFC: <https://github.com/lightningnetwork/lightning-rfc>

[2]: Miller, Andrew, et al. "Sprites and State Channels: Payment Networks that Go Faster than Lightning."

[3]: Malavolta, Giulio, et al. "Concurrency and privacy with payment-channel networks." Proceedings of the 2017 ACM SIGSAC Conference on Computer and Communications Security. ACM, 2017.

[4]: Dziembowski, Stefan, et al. PERUN: Virtual Payment Channels over Cryptographic Currencies⋆. IACR Cryptology ePrint Archive, 2017: 635, 2017.

[5]: Roos, Stefanie, et al. "Settling Payments Fast and Private: Efficient Decentralized Routing for Path-Based Transactions." arXiv preprint arXiv:1709.05748 (2017).

[6]: Tremback, Jehan, and Zack Hess. "Universal payment channels." (2015).
